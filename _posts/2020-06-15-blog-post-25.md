---
title: Overview of Motion Planning
date: 2020-06-15
permalink: /posts/2012/08/blog-post-25/
author_profile: false
tags:
  - Robotics
  - Continuous Control
---

A key concept in motion planning is configuration space, or C-space for short.
Every point in the C-space C corresponds to a unique configuration q of the
robot, and every configuration of the robot can be represented as a point in
C-space. For example, the configuration of a robot arm with n joints can be
represented as a list of n joint positions, q = (✓1, . . . , ✓n). The free C-space
Cfree consists of the configurations where the robot neither penetrates an obstacle
nor violates a joint limit.  

In this post, unless otherwise stated, we assume that q is an $n$-vector and
that C ⇢ Rn. With some generalization, the concepts of this chapter apply to
non-Euclidean C-spaces such as C = SE(3).  

The purpose of this chapter is to provide a practical overview of a few common
techniques, using robot arms and mobile robots as the primary example systems as shown in the figure.  

<p align="center"><img src="/images/motion.PNG" /></p>  

The control inputs available to drive the robot are written as an m-vector
$u \in U ⇢ R_{m}$, where $m = n$ for a typical robot arm. If the robot has second-order dynamics, such as that for a robot arm, and the control inputs are forces
(equivalently, accelerations), the state of the robot is defined by its configuration
and velocity, $x = (q, v) \in X$. For $q \in R_{n}$, typically we write v = ˙q. If we can
treat the control inputs as velocities, the state x is simply the configuration q.
The notation q(x) indicates the configuration q corresponding to the state x,
and $Xfree = \{ x | q(x) in C_{free}\}$.
The equations of motion of the robot are written  
<center>$x^{'} = f(x,u)$</center>  

or, in an integral form,  
<center>$x(T) = x(0) + \int_{0}^{T}f(x(t),u(t))dt$</center>  

__Types of Motion Planning Problems__
======  
With the definitions above, a fairly broad specification of the motion planning
problem is the following:  

_Given an initial state $x(0) = x_{start}$ and a desired final state $x_{goal}$, find a time
T and a set of controls $u : [0, T] \rightarrow U$ such that the motion equation satisfies
$x(T) = x_{goal}$ and q(x(t)) $\in C_{free}$ for all t 2 [0, T]._  

It is assumed that a feedback controller (Chapter 11) is available to ensure
that the planned motion $x(t), t \in [0, T]$, is followed closely. It is also assumed
that an accurate geometric model of the robot and environment is available to
evaluate C_{free} during motion planning.  

There are many variations of the basic problem; some are discussed below.  

__1. Path planning versus motion planning-__ The path planning problem is a
subproblem of the general motion planning problem. Path planning is the
purely geometric problem of finding a collision-free path $q(s), s \in [0, 1]$,
from a start configuration $q(0) = q_{start}$ to a goal configuration $q(1) = q_{goal}$,
without concern for the dynamics, the duration of motion, or constraints
on the motion or on the control inputs. It is assumed that the path
returned by the path planner can be time scaled to create a feasible trajectory
. This problem is sometimes called the __piano mover’s
problem__, emphasizing the focus on the geometry of cluttered spaces.  

__2. Control inputs-__ $m = n$ versus $m < n$. If there are fewer control inputs m
than degrees of freedom n, then the robot is incapable of following many
paths, even if they are collision-free. For example, a car has n = 3 (the
position and orientation of the chassis in the plane) but m = 2 (forward–
backward motion and steering); it cannot slide directly sideways into a
parking space.  

__3. Online versus offine-__ A motion planning problem requiring an immediate result,
perhaps because obstacles appear, disappear, or move unpredictably,
calls for a fast, online, planner. If the environment is static then a slower
offine planner may suffice.  

__4. Optimal versus satisficing-__ In addition to reaching the goal state, we might
want the motion plan to minimize (or approximately minimize) a cost $J$,
e.g.,  
<center>$J = \int_{0}^{T} L(x(t),u(t))dt$</center>  

__5. Exact versus approximate-__ We may be satisfied with a final state $x(T)$ that
is sufficiently close to $x_{goal}$, e.g., $|| x(T) − x_{goal}|| < \epsilon$.  

__6. With or without obstacles-__ The motion planning problem can be challenging
even in the absence of obstacles, particularly if $m < n$ or optimality is
desired.  

__Properties of Motion Planners__
======  

Planners must conform to the properties of the motion planning problem as
outlined above. In addition, planners can be distinguished by the following
properties.  

__Multiple-query versus single-query planning-__ If the robot is being asked
to solve a number of motion planning problems in an unchanging environment,
it may be worth spending the time building a data structure
that accurately represents Cfree. This data structure can then be searched
to solve multiple planning queries efficiently. Single-query planners solve
each new problem from scratch.  

__“Anytime” planning-__ An anytime planner is one that continues to look for
better solutions after a first solution is found. The planner can be stopped
at any time, for example when a specified time limit has passed, and the
best solution returned.  

__Completeness-__ A motion planner is said to be __complete__ if it is guaranteed to
find a solution in finite time if one exists, and to report failure if there is
no feasible motion plan. A weaker concept is __resolution completeness__.
A planner is resolution complete if it is guaranteed to find a solution if
one exists at the resolution of a discretized representation of the problem,
such as the resolution of a grid representation of C_{free}. Finally, a planner
is __probabilistically complete__ if the probability of finding a solution, if
one exists, tends to 1 as the planning time goes to infinity.  

__Computational complexity-__ The computational complexity refers to characterizations
of the amount of time the planner takes to run or the amount of
memory it requires. These are measured in terms of the description of the
planning problem, such as the dimension of the C-space or the number of
vertices in the representation of the robot and obstacles. For example, the
time for a planner to run may be exponential in n, the dimension of the
C-space. The computational complexity may be expressed in terms of the
average case or the worst case. Some planning algorithms lend themselves
easily to computational complexity analysis, while others do not.  

__Motion Planning Methods__
======  

There is no single planner applicable to all motion planning problems. Below
is a broad overview of some of the many motion planners available. Details are
left to the sections indicated.  

__Complete methods-__ These methods focus on exact representations
of the geometry or topology of $C_{free}$, ensuring completeness.
For all but simple or low-degree-of-freedom problems, these representations
are mathematically or computationally prohibitive to derive.  

__Grid methods-__ These methods discretize $C_{free}$ into a grid and
search the grid for a motion from qstart to a grid point in the goal region.
Modifications of the approach may discretize the state space or control
space or they may use multi-scale grids to refine the representation of Cfree
near obstacles. These methods are relatively easy to implement and can
return optimal solutions but, for a fixed resolution, the memory required
to store the grid, and the time to search it, grow exponentially with the
number of dimensions of the space. This limits the approach to lowdimensional
problems.  

__Sampling methods-__ A generic sampling method relies on a
random or deterministic function to choose a sample from the C-space
or state space; a function to evaluate whether the sample is in $X_{free}$; a
function to determine the “closest” previous free-space sample; and a local
planner to try to connect to, or move toward, the new sample from
the previous sample. This process builds up a graph or tree representing
feasible motions of the robot. Sampling methods are easy to implement,
tend to be probabilistically complete, and can even solve high-degree-offreedom
motion planning problems. The solutions tend to be satisficing,
not optimal, and it can be difficult to characterize the computational complexity.

__Virtual potential fields-__ Virtual potential fields create forces
on the robot that pull it toward the goal and push it away from obstacles.
The approach is relatively easy to implement, even for high-degree-offreedom
systems, and fast to evaluate, often allowing online implementation.
The drawback is local minima in the potential function: the robot
may get stuck in configurations where the attractive and repulsive forces
cancel but the robot is not at the goal state.  

__Nonlinear optimization-__ The motion planning problem can
be converted to a nonlinear optimization problem by representing the path
or controls by a finite number of design parameters, such as the coefficients
of a polynomial or a Fourier series. The problem is to solve for the design
parameters that minimize a cost function while satisfying constraints on
the controls, obstacles, and goal. While these methods can produce nearoptimal
solutions, they require an initial guess at the solution. Because
the objective function and feasible solution space are generally not convex,
the optimization process can get stuck far away from a feasible solution,
let alone an optimal solution.  

__Smoothing-__ Often the motions found by a planner are jerky. A smoothing algorithm can be run on the result of the motion planner to
improve the smoothness.  






