---
title: Trees and Graphs
date: 2020-06-16
permalink: /posts/2012/08/blog-post-27/
author_profile: false
tags:
  - Robotics
  - Continuous Control
---

Many motion planners explicitly or implicitly represent the C-space or state
space as a graph. A graph consists of a collection of nodes $\mathbf{N}$ and a collection
of edges $\epsilon$, where each edge $e$ connects two nodes. In motion planning, a node
typically represents a configuration or state while an edge between nodes $n_{1}$ and
$n_{2}$ indicates the ability to move from $n_{1}$ to $n_{2}$ without penetrating an obstacle
or violating other constraints.  

A graph can be either directed or undirected. In an undirected graph,
each edge is bidirectional: if the robot can travel from $n_{1}$ to $n_{2}$ then it can also
travel from $_{n2}$ to $n_{1}$. In a directed graph, or digraph for short, each edge allows
travel in only one direction. The same two nodes can have two edges between
them, allowing travel in opposite directions.  

Graphs can also be weighted or unweighted. In a weighted graph, each
edge has a positive cost associated with traversing it. In an unweighted graph
each edge has the same cost (e.g., 1). Thus the most general type of graph we
consider is a weighted digraph.  

A tree is a digraph in which (1) there are no cycles and (2) each node has
at most one parent node (i.e., at most one edge leading to the node). A tree
has one root node with no parents and a number of leaf nodes with no child.
A digraph, undirected graph, and tree are illustrated the below figure.  

<p align="center"><img src="/images/tree.PNG" /></p>  

Given $\mathbf{N}$ nodes, any graph can be represented by a matrix $A \in \mathbf{R}^{N \times N}$, where
element $a_{ij}$ of the matrix represents the cost of the edge from node $i$ to node
$j$; a zero or negative value indicates no edge between the nodes. Graphs and 
trees can be represented more compactly as a list of nodes, each with links to
its neighbors.  

__Graph Search__
======  

Once the free space is represented as a graph, a motion plan can be found by
searching the graph for a path from the start to the goal. One of the most
powerful and popular graph search algorithms is $A^{x}$ (pronounced “A star”)
search.  

The $A^{x}$ search algorithm efficiently finds a minimum-cost path on a graph when
the cost of the path is simply the sum of the positive edge costs along the path.
Given a graph described by a set of nodes $ \mathbf{N} = {1, . . . ,N}$, where node 1 is
the start node, and a set of edges $\epsilon$, the $A^{x}$ algorithm makes use of the following
data structures:  

* a sorted list OPEN of the nodes from which exploration is still to be done,
and a list CLOSED of nodes for which exploration has already taken place;  
* a matrix cost[node1,node2] encoding the set of edges, where a positive
value corresponds to the cost of moving from node1 to node2 (a negative
value indicates that no edge exists);  
* an array past_cost[node] of the minimum cost found so far to reach
node node from the start node; and  
* a search tree defined by an array parent[node], which contains for each
node a link to the node preceding it in the shortest path found so far from
the start node to that node.  

The algorithm can be presented as followed-  

<p align="center"><img src="/images/Astar.PNG" /></p>  

__Other Search Algorithms__
======  

__Dijkstra's algorithm__- If the heuristic cost-to-go is always estimated as
zero then $A^{x}$ always explores from the OPEN node that has been reached
with minimum past cost. This variant is called Dijkstra’s algorithm, which
preceded $A^{x}$ historically. Dijkstra’s algorithm is also guaranteed to find
a minimum-cost path but on many problems it runs more slowly than
$A^{x}$ owing to the lack of a heuristic look-ahead function to help guide the
search.  

__Breadth-first search__- If each edge in E has the same cost, Dijkstra’s
algorithm reduces to breadth-first search. All nodes one edge away from
the start node are considered first, then all nodes two edges away, etc.
The first solution found is therefore a minimum-cost path.  

__Suboptimal $A^{x}$ search__- If the heuristic cost-to-go is overestimated by
multiplying the optimistic heuristic by a constant factor $\eta$ > 1, the $A^{x}$
search will be biased to explore from nodes closer to the goal rather than
nodes with a low past cost. This may cause a solution to be found more
quickly but, unlike the case of an optimistic cost-to-go heuristic, the solution
will not be guaranteed to be optimal. One possibility is to run $A^{x}$
with an inflated cost-to-go to find an initial solution, then rerun the search
with progressively smaller values of $\eta$ until the time allotted for the search
has expired or a solution is found with $\eta = 1$.  



